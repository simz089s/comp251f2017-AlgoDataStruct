\documentclass[11pt,letterpaper]{article}
%\documentclass[11pt,letterpaper]{exam}
\usepackage[latin1]{inputenc}
\usepackage[left=3.00cm, right=3.00cm, top=3.00cm, bottom=3.00cm]{geometry}

\usepackage{amsmath}
%\usepackage{amsthm}
%\usepackage{cancel}
\usepackage{mathtools}
%\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
%\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage{fancyhdr}
\pagestyle{fancy}

\usepackage{color}
%\usepackage{xcolor}
%\usepackage{graphicx}
\usepackage{caption}
%\definecolor{acolour}{rgb}{0,0.0,0}

%\usepackage{url}
\usepackage{listings}
%\usepackage[]{algorithm2e}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	%frame=tb,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\newcounter{nalg}[section] % defines algorithm counter for chapter-level
\renewcommand{\thenalg}{\thechapter .\arabic{nalg}} %defines appearance of the algorithm counter
\DeclareCaptionLabelFormat{algocaption}{Algorithm \thenalg} % defines a new caption label as Algorithm x.y

\lstnewenvironment{algorithm}[1][] %defines the algorithm listing environment
{   
    \refstepcounter{nalg} %increments algorithm number
    \captionsetup{labelformat=algocaption,labelsep=colon} %defines the caption setup for: it uses label format as the declared caption label above and makes label and caption text to be separated by a ':'
    \lstset{ %this is the stype
        mathescape=true,
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        basicstyle=\scriptsize, 
        keywordstyle=\color{blue}\bfseries\em,
        keywords={,input, output, return, datatype, function, in, if, else, foreach, while, begin, end, true, false, int, for, then, } %add the keywords you want, or load a language as Rubens explains in his comment above.
        numbers=left,
        xleftmargin=.02\textwidth,
        #1 % this is to add specific settings to an usage of this environment (for instnce, the caption and referable label)
    }
}
{}

\author{Simon Zheng\\260744353}
\title{Homework 3}
\date{November 3$^{\textnormal{rd}}$, 2017}
\lhead{COMP 251}
%\chead{Homework $$}
\rhead{Algorithms and Data Structures}

\begin{document}
	\maketitle
	\thispagestyle{fancy}
	
	\section{}
		First, include all leaves as no 2 leaves can be adjacent in a graph with more than 2 vertices (cases with a graph containing less than 3 vertices are trivial). Then, with the remaining vertices, 2-colour them and keep the biggest set.
		
		For $n>2$, every leaf will only have an internal vertex by the property of being in a tree. Between two adjacent vertices where one is a leaf (single neighbour) and one is an internal vertex (more than 1 neighbour), choosing the leaf allows us to also choose any of the internal vertex's neighbours, while choosing the internal vertex removes the possibility of choosing the leaf or any of it's neighbours.
		Thus, along with the fact that no two leaves can be adjacent for $n>2$, choosing the leaf is more advantageous and will allow for a bigger set.
		
	\section{}
		For any order of processing chosen, pick 2 successive jobs.
		The finishing time of each is the processing time of the previous job plus its own. Thus if the processing time of the first one is $t_1$, both finishing times must be at least as long as $t_1$.
		So if $t_1 > t_2$, then both finishing times must be as long as the longest processing time.
		But if we reverse the job order (so where $t_1 > t_2$ still applies), then both jobs' finishing times must only be as long as the shorter one ($t_2$) and $t_2$'s finishing time will be shorter than the first case.
		Therefore, it is always more optimal to put the shorter job first.
		Now, applies this to every successive pair of jobs from ($t_1$, $t_2$), ($t_2$, $t_3$), ... , ($t_{n-1}$, $t_n$) and we will get the optimal solution, which is exactly putting them in increasing order according to their processing time.
		
	\section{}
		Using a proof by induction, we will show that the algorithm works with 2 processors with the conditions in the question and thus show it works for $n+1$ processors (our base case is one processor which is proven in the previous question).
		
		Beginning with both processors free and a set of jobs, pick two jobs and give them to the processors. For this basic case it is obvious that picking the shortest job is optimal as the average finishing time is $\frac{t_1 + t_2}{2}$. It is a similar reasoning to the previous question.
		
		Now, for the next job, if the two previous jobs had the same length then we are back to the previous case.
		Otherwise we have a processor that finished first, and therefore was available sooner, and the other one that finished after, and therefore had a longer job.
		
		If we give the next job (that takes time $t_i$) to the processor that finished sooner (with, say, finishing time $f_1$), then the total finishing time is now $f_1 + t_i$.
		If we give it to the processor that finished later at time $f_2$ then it is $f_2 + t_i$.
		
	\section{}
		?
		
	\section{}
		Graph, edge weight between two points (vertices) is distance, put edges in graph matrix and sort.
		
	\section{}
		Hybrid reverse Prim's/Dijkstra's algorithm except don't remove vertices in F.
		
		Start with putting all of the edges in a set. Remove one by one the most costly edge every time but without removing vertices of $F$.
	
\end{document}
